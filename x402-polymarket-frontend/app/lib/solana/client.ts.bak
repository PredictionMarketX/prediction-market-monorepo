import { Connection, PublicKey, SystemProgram, Keypair } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction } from '@solana/spl-token';
import { BN, Program } from '@coral-xyz/anchor';
import {
  getPredictionMarketProgram,
  PDAHelper,
  parseUSDC,
  formatUSDC,
  PROGRAM_CONFIG,
} from './program';
import type {
  Market,
  Config,
  UserInfo,
  CreateMarketParams,
  SwapParams,
  AddLiquidityParams,
  WithdrawLiquidityParams,
  MintCompleteSetParams,
  RedeemCompleteSetParams,
  TransactionResult,
  TokenType,
  TradeDirection,
  PredictionMarket,
} from './types';

/**
 * Prediction Market Client
 * Handles all interactions with the prediction market program
 */
export class PredictionMarketClient {
  private program: Program<PredictionMarket>;
  private connection: Connection;
  public wallet: any;

  constructor(connection: Connection, wallet: any) {
    this.connection = connection;
    this.wallet = wallet;
    this.program = getPredictionMarketProgram(connection, wallet);
  }

  /**
   * Fetch global config
   */
  async getConfig(): Promise<Config | null> {
    try {
      const [configPDA] = PDAHelper.getConfigPDA();
      const config = await this.program.account.config.fetch(configPDA);
      return config as Config;
    } catch (error) {
      console.error('Failed to fetch config:', error);
      return null;
    }
  }

  /**
   * Fetch market data
   */
  async getMarket(marketAddress: PublicKey): Promise<Market | null> {
    try {
      const market = await this.program.account.market.fetch(marketAddress);
      return market as Market;
    } catch (error) {
      console.error('Failed to fetch market:', error);
      return null;
    }
  }

  /**
   * Fetch user info for a specific market
   */
  async getUserInfo(userAddress: PublicKey, marketAddress: PublicKey): Promise<UserInfo | null> {
    try {
      const [userInfoPDA] = PDAHelper.getUserInfoPDA(userAddress, marketAddress);
      const userInfo = await this.program.account.userInfo.fetch(userInfoPDA);
      return userInfo as UserInfo;
    } catch (error: any) {
      // Account not existing is expected for users who haven't interacted with the market
      if (error?.message?.includes('Account does not exist')) {
        return null;
      }
      console.error('Failed to fetch user info:', error);
      return null;
    }
  }

  /**
   * Fetch all markets
   */
  async getAllMarkets(): Promise<{ address: PublicKey; data: Market }[]> {
    try {
      const markets = await this.program.account.market.all();
      return markets.map((m) => ({
        address: m.publicKey,
        data: m.account as Market,
      }));
    } catch (error) {
      console.error('Failed to fetch markets:', error);
      return [];
    }
  }

  /**
   * Create a new prediction market
   */
  async createMarket(params: CreateMarketParams): Promise<TransactionResult> {
    try {
      const [configPDA] = PDAHelper.getConfigPDA();
      const [globalVaultPDA] = PDAHelper.getGlobalVaultPDA();

      // Get config to retrieve team wallet
      const config = await this.getConfig();
      if (!config) throw new Error('Config not found');

      // Generate keypair for YES token mint
      const yesTokenMint = Keypair.generate();

      // NO token must already exist - generate keypair and create it first
      const noTokenMint = Keypair.generate();

      const METADATA_PROGRAM_ID = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');

      // Get NO token metadata PDA
      const [noMetadataPDA] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('metadata'),
          METADATA_PROGRAM_ID.toBuffer(),
          noTokenMint.publicKey.toBuffer(),
        ],
        METADATA_PROGRAM_ID
      );

      // Get global NO token account
      const globalNoTokenAccount = await getAssociatedTokenAddress(
        noTokenMint.publicKey,
        globalVaultPDA,
        true
      );

      // Create NO token mint with global_vault as authority
      console.log('[createMarket] Creating NO token mint instruction...');
      console.log('[createMarket] IDL address:', (this.program as any)._idl?.address);
      console.log('[createMarket] Program ID:', this.program.programId.toBase58());

      // Check if mintNoToken exists
      const methodBuilder = this.program.methods.mintNoToken({
        noSymbol: `NO_${params.yesSymbol}`,
        noUri: params.yesUri,
      });

      console.log('[createMarket] Method builder created:', methodBuilder);
      console.log('[createMarket] Method builder type:', typeof methodBuilder);

      // Try building instruction with accounts
      let createNoMintIx;
      try {
        // Use remainingAccounts to manually add all accounts in the correct order
        const { Transaction, TransactionInstruction } = await import('@solana/web3.js');

        // Manually build the instruction with all accounts
        const keys = [
          { pubkey: configPDA, isSigner: false, isWritable: true }, // global_config
          { pubkey: globalVaultPDA, isSigner: false, isWritable: true }, // global_vault
          { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true }, // creator
          { pubkey: noTokenMint.publicKey, isSigner: true, isWritable: true }, // no_token
          { pubkey: noMetadataPDA, isSigner: false, isWritable: true }, // no_token_metadata_account
          { pubkey: globalNoTokenAccount, isSigner: false, isWritable: true }, // global_no_token_account
          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }, // system_program
          { pubkey: new PublicKey('SysvarRent111111111111111111111111111111111'), isSigner: false, isWritable: false }, // rent
          { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // token_program
          { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // associated_token_program
          { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false }, // mpl_token_metadata_program
        ];

        // Get discriminator from IDL
        const discriminator = Buffer.from([198, 161, 208, 188, 122, 69, 236, 128]);

        // Encode args (noSymbol and noUri as strings)
        const noSymbol = `NO_${params.yesSymbol}`;
        const noUri = params.yesUri;

        // Manually encode the instruction data
        const { BorshCoder } = await import('@coral-xyz/anchor');
        const coder = new BorshCoder((this.program as any)._idl);
        const data = coder.instruction.encode('mintNoToken', {
          noSymbol,
          noUri,
        });

        createNoMintIx = new TransactionInstruction({
          keys,
          programId: this.program.programId,
          data,
        });

        console.log('[createMarket] NO token instruction created successfully (manual)');
      } catch (error: any) {
        console.error('[createMarket] Error details:', {
          message: error.message,
          stack: error.stack,
          error: error,
        });
        throw error;
      }

      const [marketPDA] = PDAHelper.getMarketPDA(
        yesTokenMint.publicKey,
        noTokenMint.publicKey
      );

      // Get whitelist PDA - check if whitelist is enabled
      const [whitelistPDA] = PDAHelper.getWhitelistPDA(this.wallet.publicKey);

      // Check if whitelist account exists
      let whitelistAccount;
      try {
        whitelistAccount = await this.connection.getAccountInfo(whitelistPDA);
      } catch (e) {
        whitelistAccount = null;
      }

      console.log('[createMarket] Whitelist enabled:', config.whitelistEnabled);
      console.log('[createMarket] Whitelist account exists:', whitelistAccount !== null);

      // Get YES token metadata PDA
      const [yesMetadataPDA] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('metadata'),
          METADATA_PROGRAM_ID.toBuffer(),
          yesTokenMint.publicKey.toBuffer(),
        ],
        METADATA_PROGRAM_ID
      );

      // Get global YES token account
      const globalYesTokenAccount = await getAssociatedTokenAddress(
        yesTokenMint.publicKey,
        globalVaultPDA,
        true
      );

      // Manually build the create_market instruction
      console.log('[createMarket] Building create_market instruction manually...');

      const { TransactionInstruction } = await import('@solana/web3.js');
      const { BorshCoder } = await import('@coral-xyz/anchor');

      // Use program ID for optional whitelist account if not needed
      const whitelistAccountKey = (config.whitelistEnabled && whitelistAccount)
        ? whitelistPDA
        : this.program.programId;

      console.log('[createMarket] Using whitelist account:', whitelistAccountKey.toBase58());

      const createMarketKeys = [
        { pubkey: configPDA, isSigner: false, isWritable: true }, // global_config
        { pubkey: globalVaultPDA, isSigner: false, isWritable: true }, // global_vault
        { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true }, // creator
        { pubkey: whitelistAccountKey, isSigner: false, isWritable: false }, // creator_whitelist (optional)
        { pubkey: yesTokenMint.publicKey, isSigner: true, isWritable: true }, // yes_token
        { pubkey: noTokenMint.publicKey, isSigner: false, isWritable: false }, // no_token
        { pubkey: marketPDA, isSigner: false, isWritable: true }, // market
        { pubkey: yesMetadataPDA, isSigner: false, isWritable: true }, // yes_token_metadata_account
        { pubkey: noMetadataPDA, isSigner: false, isWritable: true }, // no_token_metadata_account
        { pubkey: globalYesTokenAccount, isSigner: false, isWritable: true }, // global_yes_token_account
        { pubkey: globalNoTokenAccount, isSigner: false, isWritable: true }, // global_no_token_account
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }, // system_program
        { pubkey: new PublicKey('SysvarRent111111111111111111111111111111111'), isSigner: false, isWritable: false }, // rent
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // token_program
        { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // associated_token_program
        { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false }, // mpl_token_metadata_program
        { pubkey: config.teamWallet, isSigner: false, isWritable: true }, // team_wallet (needs to be writable)
      ];

      // Encode create_market args with correct field names and types
      const coder = new BorshCoder((this.program as any)._idl);
      const createMarketData = coder.instruction.encode('createMarket', {
        params: {
          yesSymbol: params.yesSymbol,
          yesUri: params.yesUri,
          startSlot: params.startSlot ? new BN(params.startSlot) : null,
          endingSlot: params.endingSlot ? new BN(params.endingSlot) : null,
          displayName: params.yesSymbol, // Use symbol as display name for now
          initialYesProb: 5000, // 50% default probability (in basis points)
        }
      });

      const createMarketIx = new TransactionInstruction({
        keys: createMarketKeys,
        programId: this.program.programId,
        data: createMarketData,
      });

      console.log('[createMarket] create_market instruction built successfully');

      // Build transaction with both instructions
      const { Transaction } = await import('@solana/web3.js');
      const tx = new Transaction();

      // Add both instructions
      tx.add(createNoMintIx);  // First create NO mint
      tx.add(createMarketIx);  // Then create market

      // Get fresh blockhash
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;
      tx.feePayer = this.wallet.publicKey;

      console.log('[createMarket] Blockhash obtained:', blockhash);

      // Sign with keypairs first (NO token for first ix, YES token for second ix)
      tx.sign(noTokenMint, yesTokenMint);

      console.log('[createMarket] Keypairs signed, requesting wallet signature...');

      // Then sign with wallet
      const signedTx = await this.wallet.signTransaction(tx);

      console.log('[createMarket] Wallet signed, sending transaction...');

      // Send with skipPreflight to avoid simulation issues
      const signature = await this.connection.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: false,
        maxRetries: 3,
      });

      console.log('[createMarket] Transaction sent:', signature);

      // Wait for confirmation with processed commitment
      const confirmation = await this.connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight,
      }, 'confirmed');

      console.log('[createMarket] Transaction confirmed:', confirmation);

      return { signature, success: true };
    } catch (error: any) {
      console.error('Failed to create market:', error);
      return { signature: '', success: false, error: error.message };
    }
  }

  /**
   * Swap tokens (buy/sell YES or NO tokens)
   */
  async swap(params: SwapParams): Promise<TransactionResult> {
    try {
      const market = await this.getMarket(params.market);
      if (!market) throw new Error('Market not found');

      const [configPDA] = PDAHelper.getConfigPDA();
      const [globalVaultPDA] = PDAHelper.getGlobalVaultPDA();
      const [marketPDA] = PDAHelper.getMarketPDA(market.yesTokenMint, market.noTokenMint);
      const [marketUsdcVaultPDA] = PDAHelper.getMarketUsdcVaultPDA(params.market);
      const [userInfoPDA] = PDAHelper.getUserInfoPDA(this.wallet.publicKey, params.market);

      const config = await this.getConfig();
      if (!config) throw new Error('Config not found');

      // Get USDC mint from config (market doesn't have usdcMint field)
      const usdcMint = config.usdcMint;

      // Get user's USDC ATA
      const userUsdcAta = await getAssociatedTokenAddress(
        usdcMint,
        this.wallet.publicKey
      );

      // Get user's YES/NO token ATAs
      const userYesAta = await getAssociatedTokenAddress(
        market.yesTokenMint,
        this.wallet.publicKey
      );
      const userNoAta = await getAssociatedTokenAddress(
        market.noTokenMint,
        this.wallet.publicKey
      );

      // Global vault token accounts
      const globalYesAta = await getAssociatedTokenAddress(
        market.yesToken,
        globalVaultPDA,
        true
      );
      const globalNoAta = await getAssociatedTokenAddress(
        market.noToken,
        globalVaultPDA,
        true
      );

      // Market USDC vault ATA
      const marketUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        marketUsdcVaultPDA,
        true
      );

      // Team USDC ATA
      const teamUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        config.teamWallet
      );

      const signature = await this.program.methods
        .swap(
          { [params.tokenType === 0 ? 'yes' : 'no']: {} },
          { [params.direction === 0 ? 'buy' : 'sell']: {} },
          parseUSDC(params.amount),
          params.minOutput ? parseUSDC(params.minOutput) : new BN(0)
        )
        .accounts({
          globalConfig: configPDA,
          teamWallet: config.teamWallet,
          market: marketPDA,
          globalVault: globalVaultPDA,
          yesToken: market.yesToken,
          noToken: market.noToken,
          globalYesAta,
          globalNoAta,
          userYesAta,
          userNoAta,
          userInfo: userInfoPDA,
          usdcMint: market.usdcMint,
          marketUsdcAta,
          marketUsdcVault: marketUsdcVaultPDA,
          userUsdcAta,
          teamUsdcAta,
          user: this.wallet.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error: any) {
      console.error('Failed to swap:', error);
      return { signature: '', success: false, error: error.message };
    }
  }

  /**
   * Add liquidity to a market
   */
  async addLiquidity(params: AddLiquidityParams): Promise<TransactionResult> {
    try {
      const market = await this.getMarket(params.market);
      if (!market) throw new Error('Market not found');

      const [configPDA] = PDAHelper.getConfigPDA();
      const [globalVaultPDA] = PDAHelper.getGlobalVaultPDA();
      const [marketPDA] = PDAHelper.getMarketPDA(market.yesToken, market.noToken);
      const [marketUsdcVaultPDA] = PDAHelper.getMarketUsdcVaultPDA(params.market);
      const [lpPositionPDA] = PDAHelper.getLPPositionPDA(params.market, this.wallet.publicKey);

      const userUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        this.wallet.publicKey
      );

      // Global vault token accounts
      const globalYesAta = await getAssociatedTokenAddress(
        market.yesToken,
        globalVaultPDA,
        true
      );
      const globalNoAta = await getAssociatedTokenAddress(
        market.noToken,
        globalVaultPDA,
        true
      );

      // Market USDC vault ATA
      const marketUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        marketUsdcVaultPDA,
        true
      );

      const signature = await this.program.methods
        .addLiquidity(parseUSDC(params.usdcAmount))
        .accounts({
          globalConfig: configPDA,
          market: marketPDA,
          yesToken: market.yesToken,
          noToken: market.noToken,
          globalVault: globalVaultPDA,
          globalYesAta,
          globalNoAta,
          usdcMint: market.usdcMint,
          marketUsdcAta,
          marketUsdcVault: marketUsdcVaultPDA,
          userUsdcAta,
          lpPosition: lpPositionPDA,
          user: this.wallet.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        })
        .rpc();

      return { signature, success: true };
    } catch (error: any) {
      console.error('Failed to add liquidity:', error);
      return { signature: '', success: false, error: error.message };
    }
  }

  /**
   * Withdraw liquidity from a market
   */
  async withdrawLiquidity(params: WithdrawLiquidityParams): Promise<TransactionResult> {
    try {
      const market = await this.getMarket(params.market);
      if (!market) throw new Error('Market not found');

      const [configPDA] = PDAHelper.getConfigPDA();
      const [globalVaultPDA] = PDAHelper.getGlobalVaultPDA();
      const [marketPDA] = PDAHelper.getMarketPDA(market.yesToken, market.noToken);
      const [marketUsdcVaultPDA] = PDAHelper.getMarketUsdcVaultPDA(params.market);
      const [lpPositionPDA] = PDAHelper.getLPPositionPDA(params.market, this.wallet.publicKey);

      const userUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        this.wallet.publicKey
      );

      // Global vault token accounts
      const globalYesAta = await getAssociatedTokenAddress(
        market.yesToken,
        globalVaultPDA,
        true
      );
      const globalNoAta = await getAssociatedTokenAddress(
        market.noToken,
        globalVaultPDA,
        true
      );

      // Market USDC vault ATA
      const marketUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        marketUsdcVaultPDA,
        true
      );

      const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');

      const signature = await this.program.methods
        .withdrawLiquidity(new BN(params.lpSharesAmount), new BN(0))
        .accounts({
          globalConfig: configPDA,
          market: marketPDA,
          yesToken: market.yesToken,
          noToken: market.noToken,
          globalVault: globalVaultPDA,
          globalYesAta,
          globalNoAta,
          usdcMint: market.usdcMint,
          marketUsdcAta,
          marketUsdcVault: marketUsdcVaultPDA,
          userUsdcAta,
          lpPosition: lpPositionPDA,
          user: this.wallet.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        })
        .rpc();

      return { signature, success: true };
    } catch (error: any) {
      console.error('Failed to withdraw liquidity:', error);
      return { signature: '', success: false, error: error.message };
    }
  }

  /**
   * Mint complete set (get 1 YES + 1 NO for 1 USDC)
   */
  async mintCompleteSet(params: MintCompleteSetParams): Promise<TransactionResult> {
    try {
      const market = await this.getMarket(params.market);
      if (!market) throw new Error('Market not found');

      const [configPDA] = PDAHelper.getConfigPDA();
      const [globalVaultPDA] = PDAHelper.getGlobalVaultPDA();
      const [marketPDA] = PDAHelper.getMarketPDA(market.yesToken, market.noToken);
      const [marketUsdcVaultPDA] = PDAHelper.getMarketUsdcVaultPDA(params.market);
      const [userInfoPDA] = PDAHelper.getUserInfoPDA(this.wallet.publicKey, params.market);

      const userUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        this.wallet.publicKey
      );
      const userYesAta = await getAssociatedTokenAddress(
        market.yesToken,
        this.wallet.publicKey
      );
      const userNoAta = await getAssociatedTokenAddress(
        market.noToken,
        this.wallet.publicKey
      );

      // Market USDC vault ATA
      const marketUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        marketUsdcVaultPDA,
        true
      );

      const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');

      const signature = await this.program.methods
        .mintCompleteSet(parseUSDC(params.usdcAmount))
        .accounts({
          globalConfig: configPDA,
          market: marketPDA,
          globalVault: globalVaultPDA,
          yesToken: market.yesToken,
          noToken: market.noToken,
          userYesAta,
          userNoAta,
          usdcMint: market.usdcMint,
          marketUsdcVault: marketUsdcVaultPDA,
          marketUsdcAta,
          userUsdcAta,
          userInfo: userInfoPDA,
          user: this.wallet.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        })
        .rpc();

      return { signature, success: true };
    } catch (error: any) {
      console.error('Failed to mint complete set:', error);
      return { signature: '', success: false, error: error.message };
    }
  }

  /**
   * Redeem complete set (burn 1 YES + 1 NO to get 1 USDC back)
   */
  async redeemCompleteSet(params: RedeemCompleteSetParams): Promise<TransactionResult> {
    try {
      const market = await this.getMarket(params.market);
      if (!market) throw new Error('Market not found');

      const [configPDA] = PDAHelper.getConfigPDA();
      const [globalVaultPDA] = PDAHelper.getGlobalVaultPDA();
      const [marketPDA] = PDAHelper.getMarketPDA(market.yesToken, market.noToken);
      const [marketUsdcVaultPDA] = PDAHelper.getMarketUsdcVaultPDA(params.market);
      const [userInfoPDA] = PDAHelper.getUserInfoPDA(this.wallet.publicKey, params.market);

      const userUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        this.wallet.publicKey
      );
      const userYesAta = await getAssociatedTokenAddress(
        market.yesToken,
        this.wallet.publicKey
      );
      const userNoAta = await getAssociatedTokenAddress(
        market.noToken,
        this.wallet.publicKey
      );

      // Market USDC vault ATA
      const marketUsdcAta = await getAssociatedTokenAddress(
        market.usdcMint,
        marketUsdcVaultPDA,
        true
      );

      const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');

      const signature = await this.program.methods
        .redeemCompleteSet(new BN(params.amount))
        .accounts({
          globalConfig: configPDA,
          market: marketPDA,
          globalVault: globalVaultPDA,
          marketUsdcVault: marketUsdcVaultPDA,
          usdcMint: market.usdcMint,
          marketUsdcAta,
          yesToken: market.yesToken,
          noToken: market.noToken,
          userYesAta,
          userNoAta,
          userUsdcAta,
          userInfo: userInfoPDA,
          user: this.wallet.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        })
        .rpc();

      return { signature, success: true };
    } catch (error: any) {
      console.error('Failed to redeem complete set:', error);
      return { signature: '', success: false, error: error.message };
    }
  }

  /**
   * Calculate current price for a token type
   */
  calculatePrice(market: Market, tokenType: TokenType): number {
    // Handle undefined reserves (new markets)
    if (!market.yesReserve || !market.noReserve) {
      return 0.5; // Default 50/50 for new markets
    }

    const yesReserve = market.yesReserve.toNumber();
    const noReserve = market.noReserve.toNumber();
    const total = yesReserve + noReserve;

    if (total === 0) return 0.5;

    if (tokenType === 0) {
      // YES token
      return noReserve / total;
    } else {
      // NO token
      return yesReserve / total;
    }
  }
}
